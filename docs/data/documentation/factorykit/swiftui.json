{"kind":"article","hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Factory can make SwiftUI easier to use when we’re using view models or services and those entities depend on internal dependencies. Let’s take a look.","type":"text"}]},{"type":"heading","level":2,"text":"StateObjects","anchor":"StateObjects"},{"type":"paragraph","inlineContent":[{"text":"Factory can be used to assign a fully constructed dependency to a ","type":"text"},{"code":"StateObject","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"ObservedObject","type":"codeVoice"},{"text":".","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ the view model","class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    @Published var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @StateObject var viewModel = Container.shared.contentViewModel()","    var body: some View {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Keep in mind that if you assign to an ","type":"text"},{"code":"ObservedObject","type":"codeVoice"},{"text":" your Factory is responsible for managing the object’s lifecycle (see the section on Scopes).","type":"text"}]},{"type":"heading","level":2,"text":"InjectedObject","anchor":"InjectedObject"},{"type":"paragraph","inlineContent":[{"text":"Then again, if your view model is coming from Factory, we can bypass the shared container code and just use the ","type":"text"},{"code":"InjectedObject","type":"codeVoice"},{"text":" property wrapper.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ the view","struct ContentView: View {","    @InjectedObject(\\.contentViewModel) private var viewModel","    var body: some View {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"InjectedObject uses ","type":"text"},{"code":"StateObject","type":"codeVoice"},{"text":" under the hood, so ownership is implied.","type":"text"}]},{"type":"heading","level":2,"text":"ViewModel Dependencies","anchor":"ViewModel-Dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that our view model used the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected"},{"type":"text","text":" property wrapper to obtain its dependency."}]},{"type":"codeListing","code":["class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    ...","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"As such, there’s no particular reason to obtain the view model from Factory since the view model knows what it needs and it’s perfectly capable of managing things for itself.","type":"text"}]},{"type":"codeListing","code":["struct ContentView: View {","    @StateObject private var viewModel = ContentViewModel()","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"That would be different if, for example, our view model wanted its dependencies passed via an initializer."}]},{"type":"codeListing","code":["class ContentViewModel: ObservableObject {","    private let service: MyServiceType","    init(service: MyServiceType)","        self.service = service","    }","    ...","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In which case we might indeed want our container to provide a fully initialized object.","type":"text"}]},{"type":"codeListing","code":["extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel(service: myService()) }","    }","    var myService: Factory<MyServiceType> {","        self { MyService() }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"And back to ","type":"text"},{"code":"InjectedObject","type":"codeVoice"},{"text":" we go.","type":"text"}]},{"type":"heading","text":"Observation","anchor":"Observation","level":2},{"inlineContent":[{"type":"text","text":"Apple added support for a new framework to iOS 17–Observation. Observation promises better efficiency and fewer view updates when used across multiple views. So how do we use it?"}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s our previous example, updated for Observation.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}"]},{"inlineContent":[{"type":"text","text":"We replaced the "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" protocol conformance with the "},{"type":"codeVoice","code":"@Observable"},{"type":"text","text":" macro and removed the "},{"type":"codeVoice","code":"@Published"},{"type":"text","text":" attribute from results."}],"type":"paragraph"},{"inlineContent":[{"text":"Note, however, that we needed to add ","type":"text"},{"code":"@ObservationIgnored","type":"codeVoice"},{"text":" to our ","type":"text"},{"code":"Injected","type":"codeVoice"},{"text":" service property wrapper. It’s a private value and doesn’t need to be visible outside of our view model.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s the view.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"]},{"inlineContent":[{"text":"Instead of ","type":"text"},{"code":"InjectedObject","type":"codeVoice"},{"text":" we use ","type":"text"},{"code":"InjectedObservable","type":"codeVoice"},{"text":", a new property wrapper that understands how to work with the Observable protocol established by Observation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"InjectedObservable uses "},{"type":"codeVoice","code":"State"},{"type":"text","text":" under the hood and, like "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":", owns the instance in question."}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"One should also note that InjectedObject “thunks” its parameter and only one instance of the injected view model will be created for the lifetime of the view.","type":"text"}]}],"type":"paragraph"},{"type":"heading","text":"Coping With @MainActor","anchor":"Coping-With-MainActor","level":2},{"inlineContent":[{"text":"One last thing missing from our SwiftUI sample code is @MainActor, that Swift Concurrency attribute used to ensure all view updates occur on the main thread.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let’s update our view model and see what else needs to change."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ the view model","@MainActor","@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    @MainActor","    var contentViewModel: Factory<ContentViewModel> {","        self { @MainActor in ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"]},{"inlineContent":[{"type":"text","text":"As you can see adding "},{"code":"@MainActor","type":"codeVoice"},{"text":" to our view model also required us to annotate the Factory accordingly, adding it to both the definition ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"and","type":"text"}]},{"text":" to the factory closure.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"While we’d never do it in this case, adding actor isolation to the base factory also means that we’d need to do so again should we ever want to register a new factory."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["Container.shared.contentViewModel.register { ","    @MainActor in ContentViewModel()","}",""]}],"kind":"content"}],"metadata":{"modules":[{"name":"FactoryKit"}],"role":"article","roleHeading":"Article","title":"SwiftUI"},"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"type":"text","text":"Defining and using dependencies in SwiftUI."}],"identifier":{"url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/SwiftUI","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/swiftui"]}],"seeAlsoSections":[{"generated":true,"anchor":"Development-and-Testing","identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains"],"title":"Development and Testing"}],"sections":[],"references":{"doc://FactoryKit/documentation/FactoryKit":{"type":"topic","role":"collection","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","kind":"symbol","abstract":[{"type":"text","text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"url":"\/documentation\/factorykit","title":"FactoryKit"},"doc://FactoryKit/documentation/FactoryKit/Contexts":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"text","text":"Changing injection results under special circumstances."}],"url":"\/documentation\/factorykit\/contexts","title":"Contexts","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts"},"doc://FactoryKit/documentation/FactoryKit/Debugging":{"role":"article","url":"\/documentation\/factorykit\/debugging","kind":"article","type":"topic","title":"Debugging","abstract":[{"type":"text","text":"Additional support for debugging resolution cycles, dependency chains and other issue."}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging"},"doc://FactoryKit/documentation/FactoryKit/Injected":{"type":"topic","kind":"symbol","title":"Injected","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected","navigatorTitle":[{"text":"Injected","kind":"identifier"}],"role":"symbol","abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Injected","kind":"identifier"}],"url":"\/documentation\/factorykit\/injected"},"doc://FactoryKit/documentation/FactoryKit/Previews":{"kind":"article","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","abstract":[{"text":"Mocking dependencies for SwiftUI Previews.","type":"text"}],"role":"article","url":"\/documentation\/factorykit\/previews","title":"SwiftUI Previews"},"doc://FactoryKit/documentation/FactoryKit/Chains":{"url":"\/documentation\/factorykit\/chains","type":"topic","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains","abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"title":"Circular Dependency Chains","role":"article"},"doc://FactoryKit/documentation/FactoryKit/Testing":{"url":"\/documentation\/factorykit\/testing","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","type":"topic","role":"article","title":"Testing","kind":"article","abstract":[{"text":"Using Factory for Unit and UI Testing.","type":"text"}]}}}