{"sections":[],"metadata":{"modules":[{"name":"FactoryKit"}],"title":"SwiftUI","roleHeading":"Article","role":"article"},"kind":"article","schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/SwiftUI","interfaceLanguage":"swift"},"seeAlsoSections":[{"identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains"],"generated":true,"title":"Development and Testing","anchor":"Development-and-Testing"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/swiftui"]}],"hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Overview","type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"Factory can make SwiftUI easier to use when we’re using view models or services and those entities depend on internal dependencies. Let’s take a look."}],"type":"paragraph"},{"level":2,"anchor":"StateObjects","type":"heading","text":"StateObjects"},{"inlineContent":[{"type":"text","text":"Factory can be used to assign a fully constructed dependency to a "},{"type":"codeVoice","code":"StateObject"},{"type":"text","text":" or "},{"type":"codeVoice","code":"ObservedObject"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["\/\/ the view model","class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    @Published var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @StateObject var viewModel = Container.shared.contentViewModel()","    var body: some View {","        ...","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Keep in mind that if you assign to an "},{"type":"codeVoice","code":"ObservedObject"},{"type":"text","text":" your Factory is responsible for managing the object’s lifecycle (see the section on Scopes)."}],"type":"paragraph"},{"level":2,"anchor":"InjectedObject","type":"heading","text":"InjectedObject"},{"inlineContent":[{"type":"text","text":"Then again, if your view model is coming from Factory, we can bypass the shared container code and just use the "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":" property wrapper."}],"type":"paragraph"},{"code":["\/\/ the view","struct ContentView: View {","    @InjectedObject(\\.contentViewModel) private var viewModel","    var body: some View {","        ...","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"InjectedObject uses "},{"type":"codeVoice","code":"StateObject"},{"type":"text","text":" under the hood, so ownership is implied."}],"type":"paragraph"},{"level":2,"anchor":"ViewModel-Dependencies","type":"heading","text":"ViewModel Dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that our view model used the "},{"isActive":true,"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected","type":"reference"},{"type":"text","text":" property wrapper to obtain its dependency."}]},{"code":["class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var service","    ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As such, there’s no particular reason to obtain the view model from Factory since the view model knows what it needs and it’s perfectly capable of managing things for itself."}]},{"code":["struct ContentView: View {","    @StateObject private var viewModel = ContentViewModel()","    var body: some View {","        ...","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"That would be different if, for example, our view model wanted its dependencies passed via an initializer.","type":"text"}]},{"code":["class ContentViewModel: ObservableObject {","    private let service: MyServiceType","    init(service: MyServiceType)","        self.service = service","    }","    ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In which case we might indeed want our container to provide a fully initialized object."}]},{"code":["extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel(service: myService()) }","    }","    var myService: Factory<MyServiceType> {","        self { MyService() }","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And back to "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":" we go."}]},{"type":"heading","text":"Observation","anchor":"Observation","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Apple added support for a new framework to iOS 17–Observation. Observation promises better efficiency and fewer view updates when used across multiple views. So how do we use it?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s our previous example, updated for Observation."}]},{"type":"codeListing","syntax":"swift","code":["@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"We replaced the ","type":"text"},{"code":"ObservableObject","type":"codeVoice"},{"text":" protocol conformance with the ","type":"text"},{"code":"@Observable","type":"codeVoice"},{"text":" macro and removed the ","type":"text"},{"code":"@Published","type":"codeVoice"},{"text":" attribute from results.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Note, however, that we needed to add ","type":"text"},{"code":"@ObservationIgnored","type":"codeVoice"},{"text":" to our ","type":"text"},{"code":"Injected","type":"codeVoice"},{"text":" service property wrapper. It’s a private value and doesn’t need to be visible outside of our view model.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s the view."}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of "},{"type":"codeVoice","code":"InjectedObject"},{"type":"text","text":" we use "},{"type":"codeVoice","code":"InjectedObservable"},{"type":"text","text":", a new property wrapper that understands how to work with the Observable protocol established by Observation."}]},{"type":"paragraph","inlineContent":[{"text":"InjectedObservable uses ","type":"text"},{"type":"codeVoice","code":"State"},{"text":" under the hood and, like ","type":"text"},{"type":"codeVoice","code":"InjectedObject"},{"text":", owns the instance in question.","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"One should also note that InjectedObject “thunks” its parameter and only one instance of the injected view model will be created for the lifetime of the view.","type":"text"}],"type":"emphasis"}]},{"type":"heading","anchor":"Coping-With-MainActor","text":"Coping With @MainActor","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"One last thing missing from our SwiftUI sample code is @MainActor, that Swift Concurrency attribute used to ensure all view updates occur on the main thread."}]},{"type":"paragraph","inlineContent":[{"text":"Let’s update our view model and see what else needs to change.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ the view model","@MainActor","@Observable","class ContentViewModel {","    @ObservationIgnored @Injected(\\.myService) private var service","    var results: Results","    func load() async {","        results = await service.load()","    }","}","","\/\/ the factory","extension Container {","    @MainActor","    var contentViewModel: Factory<ContentViewModel> {","        self { @MainActor in ContentViewModel() }","    }","}","","\/\/ the view","struct ContentView: View {","    @InjectedObservable(\\.contentViewModel) var viewModel","    var body: some View {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As you can see adding "},{"type":"codeVoice","code":"@MainActor"},{"type":"text","text":" to our view model also required us to annotate the Factory accordingly, adding it to both the definition "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" to the factory closure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"While we’d never do it in this case, adding actor isolation to the base factory also means that we’d need to do so again should we ever want to register a new factory."}]},{"type":"codeListing","code":["Container.shared.contentViewModel.register { ","    @MainActor in ContentViewModel()","}",""],"syntax":"swift"}]}],"abstract":[{"text":"Defining and using dependencies in SwiftUI.","type":"text"}],"references":{"doc://FactoryKit/documentation/FactoryKit/Chains":{"abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"url":"\/documentation\/factorykit\/chains","role":"article","title":"Circular Dependency Chains","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains","type":"topic"},"doc://FactoryKit/documentation/FactoryKit/Previews":{"url":"\/documentation\/factorykit\/previews","kind":"article","title":"SwiftUI Previews","type":"topic","role":"article","abstract":[{"text":"Mocking dependencies for SwiftUI Previews.","type":"text"}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews"},"doc://FactoryKit/documentation/FactoryKit/Testing":{"url":"\/documentation\/factorykit\/testing","role":"article","kind":"article","abstract":[{"text":"Using Factory for Unit and UI Testing.","type":"text"}],"type":"topic","title":"Testing","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing"},"doc://FactoryKit/documentation/FactoryKit/Debugging":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","role":"article","type":"topic","url":"\/documentation\/factorykit\/debugging","abstract":[{"text":"Additional support for debugging resolution cycles, dependency chains and other issue.","type":"text"}],"title":"Debugging","kind":"article"},"doc://FactoryKit/documentation/FactoryKit/Contexts":{"url":"\/documentation\/factorykit\/contexts","abstract":[{"type":"text","text":"Changing injection results under special circumstances."}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","kind":"article","type":"topic","role":"article","title":"Contexts"},"doc://FactoryKit/documentation/FactoryKit":{"role":"collection","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","url":"\/documentation\/factorykit","abstract":[{"text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"kind":"symbol","title":"FactoryKit"},"doc://FactoryKit/documentation/FactoryKit/Injected":{"abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type.","type":"text"}],"kind":"symbol","url":"\/documentation\/factorykit\/injected","title":"Injected","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Injected"}],"navigatorTitle":[{"kind":"identifier","text":"Injected"}]}}}