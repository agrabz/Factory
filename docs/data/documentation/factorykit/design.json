{"kind":"article","abstract":[{"text":"Rationale behind the design decisions made in Factory 1.0 and 2.0","type":"text"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"sections":[],"metadata":{"role":"article","modules":[{"name":"FactoryKit"}],"roleHeading":"Article","title":"Designing Factory"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Design"},"hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"seeAlsoSections":[{"generated":true,"anchor":"Advanced-Topics","identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modifiers","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modules","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Cycle","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Optionals","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Functional","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Tags"],"title":"Advanced Topics"}],"primaryContentSections":[{"content":[{"level":2,"text":"Factory 1.0","type":"heading","anchor":"Factory-10"},{"inlineContent":[{"text":"The first dependency injection system I wrote was ","type":"text"},{"identifier":"https:\/\/github.com\/hmlongco\/Resolver","isActive":true,"type":"reference"},{"text":". That open source project, while quite powerful and still in use in many applications, suffered from a few drawbacks.","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Resolver required pre-registration of all services up front.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Resolver uses type inference to dynamically find and return registered services from a container."}]}]}]},{"inlineContent":[{"type":"text","text":"The first drawback is relatively minor. While preregistration could lead to a performance hit on application launch, in practice the process is usually quick and not normally noticeable."}],"type":"paragraph"},{"inlineContent":[{"text":"The second issue, however, is more problematic since failure to find a matching registration for that type can lead to an application crash. In real life that isn’t usually a problem as such a thing tends to be noticed and fixed the first time you run a unit test or the second you run the application to see if your newest feature works.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"But still… could we do better? That question lead me on a quest for compile-time type safety. Several other systems have attempted to solve this, but I didn’t want to have to add a source code scanning and generation step to my build process, nor did I want to give up a lot of the control and flexibility inherent in a run-time-based system."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"I also wanted something simple, fast, clean, and easy to use."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Could I have my cake and eat it too?"}],"type":"paragraph"},{"inlineContent":[{"text":"Turns out I could.","type":"text"}],"type":"paragraph"},{"level":2,"text":"A Simple Example","type":"heading","anchor":"A-Simple-Example"},{"inlineContent":[{"type":"text","text":"Most container-based dependency injection systems require you to define in some way that a given service type is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory is no exception. Here’s a simple dependency registration as defined for Factory 1.0."}]},{"code":["extension Container {","    static let myService = Factory<MyServiceType> { ","        MyService()","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Unlike Resolver which often requires defining a plethora of nested registration functions, or SwiftUI, where defining a new environment variable requires creating a new EnvironmentKey and adding additional getters and setters, here we simply add a new ","type":"text"},{"type":"codeVoice","code":"Factory"},{"text":" to the default container. When called, the factory closure is evaluated and returns an instance of our dependency. That’s it.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Injecting and using the service where needed is equally straightforward. Here’s one way to do it.","type":"text"}]},{"code":["class ContentViewModel: ObservableObject {","    @Injected(Container.myService) private var myService","    ...","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Here our view model uses one of Factory 1.0’s ","type":"text"},{"code":"@Injected","type":"codeVoice"},{"text":" property wrappers to request the desired dependency. Similar to ","type":"text"},{"code":"@Environment","type":"codeVoice"},{"text":" in SwiftUI, we provide the property wrapper with a reference to a factory of the desired type and it resolves that type the moment ","type":"text"},{"code":"ContentViewModel","type":"codeVoice"},{"text":" is created.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"And that’s the core mechanism. In order to use the property wrapper you ","type":"text"},{"inlineContent":[{"text":"must","type":"text"}],"type":"emphasis"},{"text":" define a factory. That factory ","type":"text"},{"inlineContent":[{"type":"text","text":"must"}],"type":"emphasis"},{"text":" return the desired type when asked. Fail to do either one and the code will simply not compile.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As such, Factory is compile-time safe."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But there was still a problem…"}]},{"anchor":"Service-Locator","type":"heading","text":"Service Locator","level":2},{"inlineContent":[{"type":"text","text":"Containers in Factory 1.X were essentially namespaces, and not actual object instances that could be passed around. That made the overall syntax a lot cleaner, but that tradeoff resulted in a lack of functionality and the static class definitions prevented Factory from being used in anything other than a Service Locator role."}],"type":"paragraph"},{"type":"codeListing","code":["class ContentViewModel: ObservableObject {","    var myService = Container.myService()","    ...","}"],"syntax":"swift"},{"inlineContent":[{"text":"While that sufficed for many projects, it prevented Factory from being used or considered in projects that wanted or needed a true container-based Dependency Injection system.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So that changed in Factory 2.0. Instead of defining Factory’s as static variables on a class, they’re now defined and returned as computed variables on the container itself. And instances of a given container can be created, shared, and passed around as needed."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let’s take a look."}],"type":"paragraph"},{"type":"heading","anchor":"Factory-20","level":2,"text":"Factory 2.0"},{"inlineContent":[{"type":"text","text":"Here’s our earlier example, rebuilt for Factory 2.0."}],"type":"paragraph"},{"type":"codeListing","code":["extension Container {","    var myService: Factory<MyServiceType> {","        Factory(self) { ","            MyService()","        }","    }","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Instead of a static on the container class, this Factory is a computed variable on the container itself. Inside we define and return a Factory that matches the value promised by the computed variable."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This double-definition mechanism is required primarily because Swift doesn’t allow extensions to define new variables on an existing objects. As such, a computed variable was really the only choice."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that when we create the actual Factory we pass it a reference to the enclosing container."}],"type":"paragraph"},{"inlineContent":[{"text":"Unlike Factory 1.0 which maintained a global store, each Factory 2.0 container stores its own registrations and manages its own scope caches. This means that we can create multiple instances of the same container type, each with their own distinct registrations and caches.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Convenience","level":2,"text":"Convenience"},{"inlineContent":[{"type":"text","text":"While the formal definition does the trick, most of the time it’s easier to use some syntactic sugar and just ask the container to make our Factory for us."}],"type":"paragraph"},{"type":"codeListing","code":["extension Container {","    var myService: Factory<MyServiceType> {","        self { MyService() }","    }","}"],"syntax":"swift"},{"type":"heading","anchor":"Scopes","level":2,"text":"Scopes"},{"inlineContent":[{"text":"Factory scopes work just as they did before, only now they’re defined using a SwiftUI-like modifier syntax.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension Container {","    var myService: Factory<MyServiceType> {","        self { MyService() }","            .singleton","    }","}"],"syntax":"swift"},{"type":"heading","anchor":"Containershared","level":2,"text":"Container.shared"},{"inlineContent":[{"type":"text","text":"Each container class defined has a statically allocated "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" instance associated with it."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This instance can be referenced directly if you still want to use a Service Locator-style pattern."}],"type":"paragraph"},{"type":"codeListing","code":["let service = Container.shared.service()"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Or you can use the “shared” container as an application root container and pass it along to wherever it’s needed. Let’s take a look."}],"type":"paragraph"},{"type":"heading","anchor":"Passing-Containers","level":2,"text":"Passing Containers"},{"inlineContent":[{"text":"Here’s an example of passing an instance of a container to a view model and then initializing a service from that container. Doing this sort of thing is the primary rationale behind the changes to Factory for 2.0.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["class ContentViewModel {","    let myService: MyServiceType","    init(container: Container) {","        myService = container.myService()","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"Additional examples and methods can be seen on the ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Resolutions"},{"type":"text","text":" page."}],"type":"paragraph"},{"type":"heading","anchor":"Injected-Property-Wrappers","level":2,"text":"Injected Property Wrappers"},{"inlineContent":[{"type":"text","text":"Property wrappers like @Injected and @LazyInjected always reference the "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" container for that class type."}],"type":"paragraph"},{"type":"codeListing","code":["class ContentViewModel: ObservableObject {","    @Injected(\\.myService) var myService","}"],"syntax":"swift"},{"inlineContent":[{"text":"Factory 2.0 also updates the syntax to use keyPaths, much like SwiftUI environment variables.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"See "},{"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected","isActive":true},{"type":"text","text":", "},{"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/LazyInjected","isActive":true},{"type":"text","text":", "},{"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/WeakLazyInjected","isActive":true},{"type":"text","text":", "},{"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/DynamicInjected","isActive":true},{"type":"text","text":" and "},{"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/InjectedObject","isActive":true},{"type":"text","text":" for more."}],"type":"paragraph"},{"type":"heading","anchor":"Breaking-Changes","level":2,"text":"Breaking Changes"},{"inlineContent":[{"text":"Unfortunately, supporting true container-based DI required some major surgery on Factory 1.0’s syntax across the board. That’s why it’s version 2.0.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"But under the hood Factory 2.0 still gives you the same feature set provided by 1.0, while adding and supporting new functionality and use cases.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"I think it’s worth it.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/design"]}],"references":{"doc://FactoryKit/documentation/FactoryKit/InjectedObject":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/InjectedObject","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"InjectedObject","kind":"identifier"}],"title":"InjectedObject","role":"symbol","navigatorTitle":[{"text":"InjectedObject","kind":"identifier"}],"kind":"symbol","type":"topic","abstract":[{"text":"Immediate injection property wrapper for SwiftUI ObservableObjects.","type":"text"}],"url":"\/documentation\/factorykit\/injectedobject"},"doc://FactoryKit/documentation/FactoryKit/Cycle":{"role":"article","abstract":[{"type":"text","text":"What’s a resolution cycle, and why should we care?"}],"kind":"article","url":"\/documentation\/factorykit\/cycle","title":"Resolution Cycles","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Cycle"},"doc://FactoryKit/documentation/FactoryKit/DynamicInjected":{"title":"DynamicInjected","type":"topic","abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type.","type":"text"}],"url":"\/documentation\/factorykit\/dynamicinjected","kind":"symbol","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/DynamicInjected","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DynamicInjected","kind":"identifier"}],"navigatorTitle":[{"text":"DynamicInjected","kind":"identifier"}]},"doc://FactoryKit/documentation/FactoryKit/Modules":{"type":"topic","kind":"article","url":"\/documentation\/factorykit\/modules","abstract":[{"type":"text","text":"Using Factory in a project with multiple modules."}],"role":"article","title":"Modular Development","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modules"},"doc://FactoryKit/documentation/FactoryKit/Injected":{"type":"topic","kind":"symbol","title":"Injected","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Injected","navigatorTitle":[{"text":"Injected","kind":"identifier"}],"role":"symbol","abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Injected","kind":"identifier"}],"url":"\/documentation\/factorykit\/injected"},"doc://FactoryKit/documentation/FactoryKit/LazyInjected":{"kind":"symbol","title":"LazyInjected","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"LazyInjected"}],"abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type the first time the wrapped value is requested.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"LazyInjected"}],"url":"\/documentation\/factorykit\/lazyinjected","role":"symbol","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/LazyInjected"},"doc://FactoryKit/documentation/FactoryKit":{"type":"topic","role":"collection","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","kind":"symbol","abstract":[{"type":"text","text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"url":"\/documentation\/factorykit","title":"FactoryKit"},"doc://FactoryKit/documentation/FactoryKit/Functional":{"kind":"article","type":"topic","url":"\/documentation\/factorykit\/functional","title":"Functional Injection","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Functional","abstract":[{"text":"Factory can inject more than service classes and structs.","type":"text"}],"role":"article"},"https://github.com/hmlongco/Resolver":{"identifier":"https:\/\/github.com\/hmlongco\/Resolver","titleInlineContent":[{"type":"text","text":"Resolver"}],"url":"https:\/\/github.com\/hmlongco\/Resolver","title":"Resolver","type":"link"},"doc://FactoryKit/documentation/FactoryKit/Optionals":{"role":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Optionals","title":"Optionals and Dynamic Registration","kind":"article","abstract":[{"type":"text","text":"With Factory registrations can be performed at any time."}],"type":"topic","url":"\/documentation\/factorykit\/optionals"},"doc://FactoryKit/documentation/FactoryKit/Tags":{"role":"article","abstract":[{"type":"text","text":"Obtaining a list of dependencies of a given type."}],"kind":"article","url":"\/documentation\/factorykit\/tags","title":"Tags","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Tags"},"doc://FactoryKit/documentation/FactoryKit/WeakLazyInjected":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/WeakLazyInjected","role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WeakLazyInjected","kind":"identifier"}],"url":"\/documentation\/factorykit\/weaklazyinjected","title":"WeakLazyInjected","navigatorTitle":[{"text":"WeakLazyInjected","kind":"identifier"}],"abstract":[{"text":"Convenience property wrapper takes a factory and resolves a weak instance of the desired type the first time the wrapped value is requested.","type":"text"}],"type":"topic"},"doc://FactoryKit/documentation/FactoryKit/Resolutions":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Resolutions","abstract":[{"type":"text","text":"There are many ways to use Factory to resolve dependencies. Here are a few examples."}],"type":"topic","role":"article","kind":"article","url":"\/documentation\/factorykit\/resolutions","title":"Sample Resolutions"},"doc://FactoryKit/documentation/FactoryKit/Modifiers":{"type":"topic","kind":"article","url":"\/documentation\/factorykit\/modifiers","abstract":[{"type":"text","text":"Considerations when defining and redefining a Factory’s behavior."}],"role":"article","title":"Factory Modifiers","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modifiers"}}}